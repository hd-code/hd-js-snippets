"use strict";function clone(e){return Array.isArray(e)?e.slice():null!==e&&"object"==typeof e?Object.assign({},e):e}function deepClone(e){if(Array.isArray(e)){let r=[];for(let t=0,n=e.length;t<n;t++)r[t]=deepClone(e[t]);return r}if(null!==e&&"object"==typeof e){let r={};for(const t in e)r[t]=deepClone(e[t]);return r}return e}function flattenArray(e){return e.reduce((e,r)=>e.concat(r),[])}function getPermutations(e,r=!1){const t=permuteArray(e);return r?removeDuplicates(t):t}function hasKey(e,r,t){return!!e&&e.hasOwnProperty(r)&&(!t||t(e[r]))}function isArray(e,r){if(!Array.isArray(e))return!1;if(!r)return!0;for(let t=0,n=e.length;t<n;t++)if(!r(e[t]))return!1;return!0}function isInArray(e,r){for(let t=0,n=e.length;t<n;t++)if(r(e[t]))return!0;return!1}function isObject(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}function splitEqual(e,r){const t=e.length;let n=0,o=[];for(let s=0;s<r;s++){const l=Math.ceil((t-n)/(r-s));o[s]=[];for(let r=0;r<l;r++)o[s][r]=e[n++]}return o}function permuteArray(e){if(e.length<=1)return[e];let r=[];for(let t=0,n=e.length;t<n;t++){const n=e[t],o=permuteArray(e.filter((e,r)=>t!==r)).map(e=>[n,...e]);r=r.concat(o)}return r}function removeDuplicates(e){return e.filter((e,r,t)=>{for(let n=r+1,o=t.length;n<o;n++)if(isSameTuple(e,t[n]))return!1;return!0})}function isSameTuple(e,r){return e.length===r.length&&e.every((t,n)=>e[n]===r[n])}Object.defineProperty(exports,"__esModule",{value:!0}),exports.splitEqual=exports.isObject=exports.isInArray=exports.isArray=exports.hasKey=exports.getPermutations=exports.flattenArray=exports.deepClone=exports.clone=void 0,exports.clone=clone,exports.deepClone=deepClone,exports.flattenArray=flattenArray,exports.getPermutations=getPermutations,exports.hasKey=hasKey,exports.isArray=isArray,exports.isInArray=isInArray,exports.isObject=isObject,exports.splitEqual=splitEqual;